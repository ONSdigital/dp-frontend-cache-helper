// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package client

import (
	"context"
	topicModel "github.com/ONSdigital/dp-topic-api/models"
	"sync"
	"time"
)

// Ensure, that ClienterMock does implement Clienter.
// If this is not the case, regenerate this file with moq.
var _ Clienter = &ClienterMock{}

// ClienterMock is a mock implementation of Clienter.
//
//	func TestSomethingThatUsesClienter(t *testing.T) {
//
//		// make and configure a mocked Clienter
//		mockedClienter := &ClienterMock{
//			AddNavigationCacheFunc: func(ctx context.Context, updateInterval time.Duration) error {
//				panic("mock out the AddNavigationCache method")
//			},
//			CloseFunc: func()  {
//				panic("mock out the Close method")
//			},
//			GetNavigationDataFunc: func(ctx context.Context, lang string) (*topicModel.Navigation, error) {
//				panic("mock out the GetNavigationData method")
//			},
//			StartBackgroundUpdateFunc: func(ctx context.Context, errorChannel chan error)  {
//				panic("mock out the StartBackgroundUpdate method")
//			},
//		}
//
//		// use mockedClienter in code that requires Clienter
//		// and then make assertions.
//
//	}
type ClienterMock struct {
	// AddNavigationCacheFunc mocks the AddNavigationCache method.
	AddNavigationCacheFunc func(ctx context.Context, updateInterval *time.Duration) error

	// CloseFunc mocks the Close method.
	CloseFunc func()

	// GetNavigationDataFunc mocks the GetNavigationData method.
	GetNavigationDataFunc func(ctx context.Context, lang string) (*topicModel.Navigation, error)

	// StartBackgroundUpdateFunc mocks the StartBackgroundUpdate method.
	StartBackgroundUpdateFunc func(ctx context.Context, errorChannel chan error)

	// calls tracks calls to the methods.
	calls struct {
		// AddNavigationCache holds details about calls to the AddNavigationCache method.
		AddNavigationCache []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UpdateInterval is the updateInterval argument value.
			UpdateInterval time.Duration
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// GetNavigationData holds details about calls to the GetNavigationData method.
		GetNavigationData []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Lang is the lang argument value.
			Lang string
		}
		// StartBackgroundUpdate holds details about calls to the StartBackgroundUpdate method.
		StartBackgroundUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ErrorChannel is the errorChannel argument value.
			ErrorChannel chan error
		}
	}
	lockAddNavigationCache    sync.RWMutex
	lockClose                 sync.RWMutex
	lockGetNavigationData     sync.RWMutex
	lockStartBackgroundUpdate sync.RWMutex
}

// AddNavigationCache calls AddNavigationCacheFunc.
func (mock *ClienterMock) AddNavigationCache(ctx context.Context, updateInterval *time.Duration) error {
	if mock.AddNavigationCacheFunc == nil {
		panic("ClienterMock.AddNavigationCacheFunc: method is nil but Clienter.AddNavigationCache was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		UpdateInterval time.Duration
	}{
		Ctx:            ctx,
		UpdateInterval: *updateInterval,
	}
	mock.lockAddNavigationCache.Lock()
	mock.calls.AddNavigationCache = append(mock.calls.AddNavigationCache, callInfo)
	mock.lockAddNavigationCache.Unlock()
	return mock.AddNavigationCacheFunc(ctx, updateInterval)
}

// AddNavigationCacheCalls gets all the calls that were made to AddNavigationCache.
// Check the length with:
//
//	len(mockedClienter.AddNavigationCacheCalls())
func (mock *ClienterMock) AddNavigationCacheCalls() []struct {
	Ctx            context.Context
	UpdateInterval time.Duration
} {
	var calls []struct {
		Ctx            context.Context
		UpdateInterval time.Duration
	}
	mock.lockAddNavigationCache.RLock()
	calls = mock.calls.AddNavigationCache
	mock.lockAddNavigationCache.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *ClienterMock) Close() {
	if mock.CloseFunc == nil {
		panic("ClienterMock.CloseFunc: method is nil but Clienter.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedClienter.CloseCalls())
func (mock *ClienterMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// GetNavigationData calls GetNavigationDataFunc.
func (mock *ClienterMock) GetNavigationData(ctx context.Context, lang string) (*topicModel.Navigation, error) {
	if mock.GetNavigationDataFunc == nil {
		panic("ClienterMock.GetNavigationDataFunc: method is nil but Clienter.GetNavigationData was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Lang string
	}{
		Ctx:  ctx,
		Lang: lang,
	}
	mock.lockGetNavigationData.Lock()
	mock.calls.GetNavigationData = append(mock.calls.GetNavigationData, callInfo)
	mock.lockGetNavigationData.Unlock()
	return mock.GetNavigationDataFunc(ctx, lang)
}

// GetNavigationDataCalls gets all the calls that were made to GetNavigationData.
// Check the length with:
//
//	len(mockedClienter.GetNavigationDataCalls())
func (mock *ClienterMock) GetNavigationDataCalls() []struct {
	Ctx  context.Context
	Lang string
} {
	var calls []struct {
		Ctx  context.Context
		Lang string
	}
	mock.lockGetNavigationData.RLock()
	calls = mock.calls.GetNavigationData
	mock.lockGetNavigationData.RUnlock()
	return calls
}

// StartBackgroundUpdate calls StartBackgroundUpdateFunc.
func (mock *ClienterMock) StartBackgroundUpdate(ctx context.Context, errorChannel chan error) {
	if mock.StartBackgroundUpdateFunc == nil {
		panic("ClienterMock.StartBackgroundUpdateFunc: method is nil but Clienter.StartBackgroundUpdate was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		ErrorChannel chan error
	}{
		Ctx:          ctx,
		ErrorChannel: errorChannel,
	}
	mock.lockStartBackgroundUpdate.Lock()
	mock.calls.StartBackgroundUpdate = append(mock.calls.StartBackgroundUpdate, callInfo)
	mock.lockStartBackgroundUpdate.Unlock()
	mock.StartBackgroundUpdateFunc(ctx, errorChannel)
}

// StartBackgroundUpdateCalls gets all the calls that were made to StartBackgroundUpdate.
// Check the length with:
//
//	len(mockedClienter.StartBackgroundUpdateCalls())
func (mock *ClienterMock) StartBackgroundUpdateCalls() []struct {
	Ctx          context.Context
	ErrorChannel chan error
} {
	var calls []struct {
		Ctx          context.Context
		ErrorChannel chan error
	}
	mock.lockStartBackgroundUpdate.RLock()
	calls = mock.calls.StartBackgroundUpdate
	mock.lockStartBackgroundUpdate.RUnlock()
	return calls
}
